#!/usr/bin/env perl
use strict;
use Getopt::Long;      # for std option handling: -h --yadda=badda, etc
use Socket;
use Env qw(HOME PATH);
use File::Path qw(remove_tree);

# don't forget!!  using git!
# once verified, 
# cp ~/bin/parsyncfp ~/gits/parsyncfp/
# edit README.md
# git add  parsyncfp  README.md     # stage the file for the commit
# git commit -m 'commit message'    # stages the commit
# git push                          # pushes the commit to github

# after significant changes, update the tarball and cp to moo for distribution; update the github
# cd ; cp ~/bin/parsyncfp ~/parsync/; tar -cvzf parsync+utils.tar.gz parsync; scp parsync+utils.tar.gz moo:~/public_html/parsync ; 
# cd ~/gits/parsyncfp; cp ~/bin/parsyncfp .; git add parsyncfp README.md; git commit -m 'commit message'; git push

# TODO
# only ERROR is at 0, no scrolling output
# only WARN & ERROR is at 1, scrolling just overwrites
# INFO, WARN & ERROR & scrolling stuff is at 2
# DEBUG is at 3

# DONE - remove re-use cache - no need anymore since fpf will start transferring immediately
# make parsync commands and syntax more rsync-like.  
# DONE - ie handle barefiles transparently 
# compress and decompress chunk files /cache - maybe better is to check # of 
# chunk files while being generated and warn if > some # (1000?)
# and then based on a flag, compress or delete them after the whole run or as they're finished with.
# after the run
# DONE - handle empty dirs gracefully
# check github for bug reports.

# specification of sources
# - compress/decompress chunk files when transiting them so they don't tak up too much space.
# DONE - - use 'find . -name 'regex' ' to process lists of files rather than ls globbing.
# still using ls, but as '\ls -U' - 10X faster.
# see note from james Ziller about the faults he had:
#               /usr/bin/ls: Argument list too long
# https://goo.gl/lECBnP  & https://goo.gl/OomdIz
# or use 'find .' unaliases any ls and doesn't sort the output, so it /very/ fast
# DONE - when catching up to a previous rsync, should cycle fast until it's all 
# caught up then drop back to regular periodicity. Maybe, regardless of 
# requested cycle time, it cycles very fast for the 1st few to check that it's caught up?

use vars qw($allPIDs $ALL_SYS_RSYNC_PIDS $BAREFILES $ch $CHECKPERIOD $cmd 
$crr $CUR_FP_FLE $CUR_FPI $DATE $dcnt $DEBUG @DIRS @DIRS2SYNC $dirtmp 
$EMAIL $Filecnt %FILES $fl $fn $fnd2r $FOUT $FPART_LOGFILE $FPART_PID 
$FPART_RUNNING $FPARTSIZE $FPARTSIZE_N $FP_PIDFILE $FP_ROOT $cyclecnt
$FP_ROOT_DIR $FP_RUNNING $hdr_cnt $hdr_rpt $HELP $IF_SPEED $VERBOSE
$LOAD1mratio $loadavg $logfile $MAXBW $MAXLOAD $nbr_cur_fpc_fles 
$NBR_FP_FLES $NCPUs $NDIRS $NETIF $NOWAIT $NP $NP_chunk $glob $ALTCACHE
$parsync_dir $PARSYNCVER $PIDFILE $PIDFILE $prev_cache $lenPID $DISPOSE
$rem_host $remote $rem_path $rem_user $REUSECACHE $rootdir $rPIDs $sPIDs
$ROOTDIR $RSYNC_CMD $RSYNCOPTS $RSYNCS_GOING $STILLRSYNCS $DFLT_RSYNCOPTS
@SYSLOAD $TARGET $tmp $Totlsiz %UTILS $VERSION $OS $Linux $MacOSX $NETFILE $myIP
);

$PARSYNCVER =  << "VERSION";
parsyncfp version 1.44 (beta)
July 16, 2017
by Harry Mangalam <hjmangalam\@gmail.com> || <harry.mangalam\@uci.edu>

parsyncfp is a Perl script that wraps Andrew Tridgell's miraculous
'rsync' to provide some load balancing and parallel operation across
network connections to increase the amount of bandwidth it can use.
The 'fp' variant uses 'fpart' <https://sourceforge.net/projects/fpart/> 
to bypass the need for a full recursive descent of the dir trees before 
the actual transfer starts.
VERSION

if (! @ARGV) {usage();} # in case someone doesn't know what to do.


&GetOptions(
  "startdir|sd"      =>   \$ROOTDIR,     # Have to be able to set rootdir -> SRC in rsync
  "altcache|ac=s"    =>   \$ALTCACHE,    # alternative cache instead of ~/.parsyncfp
  "rsyncopts|ro=s"   =>   \$RSYNCOPTS,   # passthru to rsync as a string
  "NP|np=i"          =>   \$NP,          # number of rsync processes to start
  "chunksize|cs=s"   =>   \$FPARTSIZE,   # the size that fpart chunks (allow PpTtGgMmKk)
  "checkperiod|cp=i" =>   \$CHECKPERIOD, # # of sec between system load checks
  "maxbw=i"          =>   \$MAXBW,       # max bw to use (--bwlimit=KBPS passthru to rsync)
  "maxload|ml=f"     =>   \$MAXLOAD,     # max system load - if > this, sleep rsyncs
  "email=s"          =>   \$EMAIL,       # email to notify when finished
  "interface|i=s"    =>   \$NETIF,       # network interface to use if multiple ones
  "verbose|v=i"      =>   \$VERBOSE,     # how chatty it should be.
  "nowait|nw!"       =>   \$NOWAIT,      # sleep a few s rather than wait for a user ack
  "help!"            =>   \$HELP,        # dump usage, tips
  "version!"         =>   \$VERSION,     # duh..
  "disposal|d=s"     =>   \$DISPOSE,     # what to do with the cache (compress, delete, leave untouched)
  "debug|d!"         =>   \$DEBUG,       # developer-level info; (historical) alias for '-v 3'
);

## Set up run-permanent variables.
$DATE=`date +"%T_%F" | sed 's/:/./g' `; chomp $DATE;
if (! defined $ALTCACHE) {$parsync_dir = $HOME . "/.parsyncfp";}
else {$parsync_dir = $ALTCACHE; mkdir $parsync_dir;}
$NETFILE = "/proc/net/dev";
$OS = `uname -s`; chomp $OS;
$Linux = $MacOSX = 0;
if ($OS =~ /Linux/) {$Linux = 1;} else {$MacOSX = 1;}
$DFLT_RSYNCOPTS = "-a -s"; # the default options to pass to rsync; blanked if define $RSYNCOPTS
if (defined $VERSION) { print $PARSYNCVER; exit;}
if (!defined $CHECKPERIOD) {$CHECKPERIOD = 5;}
if (!defined $VERBOSE) {$VERBOSE = 2;}
if (!defined $RSYNCOPTS) {$RSYNCOPTS = ""; $DFLT_RSYNCOPTS = "-a -s";}
else {$DFLT_RSYNCOPTS = "";} # if def $RSYNCOPTS, then user takes all responsibility
#if (defined $HELP ||  @ARGV == 0) { usage(); }
if (defined $HELP) {usage($parsync_dir);}
if (!defined $DISPOSE) {$DISPOSE = 'l';} # for leave untouched

# check_utils(); # check that the required utilities are on the system

### get the current system stats:  #CPUs, load, bandwidth, etc

if ($Linux) {
    $NCPUs = `cat /proc/cpuinfo | grep processor | wc -l`; chomp $NCPUs;
    $loadavg = `cat /proc/loadavg | tr -d '\n'`;
    my $pid_max = `cat /proc/sys/kernel/pid_max`;
    $lenPID = length $pid_max;  # usually 5 but can go as high as 7
} elsif ($MacOSX) {
    $NCPUs = `sysctl -n hw.ncpu`; chomp $NCPUs;
    $loadavg = `sysctl -n vm.loadavg | cut -d" " -f2 -f3 -f4 | tr -d '\n'`;
    $lenPID = 5; # highest possible pid is 99998.
} else {die "FATAL: parsyncfp only supports Linux and MacOSX at this point\n";}

@SYSLOAD = split (/\s+/, $loadavg); # 1st 3 fields are 1, 5, 15m loads
# so as long as the 1m load / NCPUs < 1, we're fine; if > 1, we may want to start throttling..
$LOAD1mratio = $SYSLOAD[0] / $NCPUs;

if (! defined $NETIF) {
  if ($MacOSX) {
     $NETIF = `netstat -nr | grep "^default" | head -n1 | awk '{print \$6}'`; chomp $NETIF;
     $myIP = `ifconfig $NETIF | grep 'inet ' | awk '{print \$2}'`; chomp $myIP;
  } else {
    #TODO This has to be checked for multi-homed systems and if the system is multihomed, 
    # force a choice as to which one to use via --interface
    my $ifs = `/sbin/route -n | grep "^0.0.0.0" | awk '{print \$8}' | wc -l`; chomp $ifs;
    $NETIF = `/sbin/route -n | grep "^0.0.0.0" | awk '{print \$8}'`; chomp $NETIF;
    if ($ifs != '1'){
      # print "IDEBUG: ifs = [$ifs]\n";
      die "\nERROR: Your system is multi-homed - I've detected more than 1 active interface:
$NETIF \nPlease specify the one you want to use via the '--interface' flag.\n";
    } else {
      $NETIF = `/sbin/route -n | grep "^0.0.0.0" | awk '{print \$8}'`; chomp $NETIF;
      $myIP = `ifconfig $NETIF | grep 'inet ' | awk '{print \$2}' | cut -d: -f2`; chomp $myIP;
    }
  }
}

if (defined $DEBUG) {$VERBOSE = 3;} # DEBUG = VERBOSE=3
if (defined $VERBOSE && ($VERBOSE < 0 || $VERBOSE > 3)) {die "ERROR: --verbose arg must be 0-3. Try again.\n";}
if (! defined $NP){$NP = int(sqrt($NCPUs)+ 0.5);} # round sqrt(NCPUs) (hyperthreaded if Intel) 8 -> 3
if (! defined $MAXBW) {$MAXBW = 1000000;} # essentially unlimited
else {$MAXBW = int($MAXBW / $NP + 0.5);} # users expect total maxbw; so have to divide by NP.
if (! defined $MAXLOAD) {$MAXLOAD = $NP + 2 ;} #  + 1 for IO load
if (! defined $ROOTDIR) {$ROOTDIR = `pwd`; chomp $ROOTDIR;}  # where all dirs must be rooted.
if (! defined $FPARTSIZE) {$FPARTSIZE = "10G"; $FPARTSIZE_N = 104857600;} # default is 10Gish
elsif ($FPARTSIZE =~ /[PpTtGgMmKk]/) {$FPARTSIZE_N = ptgmk($FPARTSIZE); }
else {$FPARTSIZE_N = $FPARTSIZE;}
if ($DEBUG) {&debug(__LINE__, "FPARTSIZE = $FPARTSIZE\nFPARTSIZE_N = $FPARTSIZE_N");}

# ?? Is this nec anymore?  If so, need to bring it up to date with the new naming conventions
# see: https://goo.gl/kDLr8b
# get some network info
if ($NETIF =~ /eth/) {
  $IF_SPEED = `ethtool eth0 2> /dev/null | grep Speed | cut -f2 -d:`;}
elsif ($NETIF =~ /wlan/) {
  $IF_SPEED = `iwconfig wlan0 | grep -i quality`;
} elsif ($NETIF =~ /ib/) {
  $IF_SPEED = `ibstat | grep Rate | head -1 | sed -e 's/^[ \t]*//'`;
  $IF_SPEED = "IB:" . $IF_SPEED;
}
chomp $IF_SPEED;

if ($DEBUG){
  print "\tDEBUG: Using network interface [$NETIF] with connection quality [$IF_SPEED]\n\n";}
  if ($SYSLOAD[0] < $MAXLOAD){
  if ($DEBUG){
    print "\n\tDEBUG: 1m load is [$SYSLOAD[0]] and the 1m Load:#CPU ratio is [$LOAD1mratio] ( [$NCPUs] CPU cores).
	    OK to continue.\n "
  }
} else {
  print "\n!!WARN: 1m System load is > [$SYSLOAD[0]].  The 1m Load:#CPU ratio is [$LOAD1mratio].\n Continue? [Cntrl+C to interrupt; Enter to continue]\n ";
  pause();
}

$FP_ROOT_DIR = "${parsync_dir}/fpcache";

if (-d $parsync_dir && ! defined $REUSECACHE) {
  if ($VERBOSE >= 1) {print <<LS;

  WARN: about to remove all the old cached chunkfiles from [$FP_ROOT_DIR].
  Enter ^C to stop this.
        If you specified '--nowait', cache will be cleared in 3s regardless.
  Otherwise, hit [Enter] and I'll clear them.
LS
}

$glob = "${FP_ROOT_DIR}/f*";
  if ($NOWAIT){ sleep 3;}
  else {pause();}
  system("rm -f $glob");
  if ($VERBOSE >=2 ) {print "INFO: The fpart chunk files [$glob] are cleared.. continuing\n";}
} elsif (! -d $parsync_dir) {
   mkdir  $parsync_dir or die "FATAL: Can't mkdir [$parsync_dir]\n";
}

if (! -d $FP_ROOT_DIR) {mkdir $FP_ROOT_DIR or die "FATAL: Can't make 'FP_ROOT_DIR' [$FP_ROOT_DIR]\n";}
$FP_ROOT = $FP_ROOT_DIR . "/f";  # the root name of the fpart chunk files f.1, etc
$PIDFILE = $FP_ROOT_DIR . '/' . "rsync-PIDs" . '-' . $DATE;
$FPART_LOGFILE = $FP_ROOT_DIR . '/' . "fpart.log." . $DATE;
$FP_PIDFILE = $FP_ROOT_DIR . '/' . "FP_PIDFILE" . $DATE;
$hdr_rpt = 20; # nbr of lines to repeat the header
$hdr_cnt = 21;  # header counter; > $hdr_rpt so it gets printed 1st time

# this takes care of the last ARGV so that all the rest of the words are target dirs&files
$TARGET = $ARGV[$#ARGV]; # remote rsync target
if (!defined $TARGET ){die "\n\nXX FATAL XX: No target defined! Where you gonna put this stuff??!?\nTry $0 --help for the built-in help.\n"}
$#ARGV--;

# now process the dirs
$dcnt = 0;
$fnd2r = "";  # zero the list of 'files 'n' dirs to rsync'
$dirtmp = shift; # should only be dir/files left once getopt finishes (see above)

# If there are no files or dirs defined, take the current dir
if (!defined $dirtmp) { $dirtmp = `pwd`;}
#print "DEBUG: dirtmp = [$dirtmp]\n";
while (defined $dirtmp) { # should work on explicitly named dirs as well as globs.
  $dirtmp = $ROOTDIR . '/' . $dirtmp;
  if (! -r $dirtmp){ # quick check to see if its readable.
    print "WARN: [$dirtmp] isn't readable; either it's not where you think it\nis or you need to escalate your privs.  Regardless, it won't be transferred in this run.\n";
  } else {  # otherwise, add the file to list to be chunked and  transferred.
    $fnd2r .= $dirtmp . " ";
  }
  $dirtmp = shift;
}
$#ARGV++; # now incr to allow the TARGET to be captured.
my @cachefiles = (); # will populate with list of cachefiles to process together.

# ### TODO REUSECACHE
# my $rsls = `ls -1 $FP_ROOT_DIR`;
# #print "DEBUG: rsls = $rsls\n";
# my $glob =  $FP_ROOT_DIR . "/f.*";
# if ($rsls =~ 'f') {$prev_cache = `ls -1 $glob`; }
# elsif (defined $REUSECACHE){
#   print "!!WARN: You chose '--reusecache', but there's no files for it. Unsetting that option\n\n.";
#   undef $REUSECACHE; sleep 1;
# }

# ## This is the big REUSECACHE SECTION.  ONlY enter if want to REUSECACHE
# if (defined $REUSECACHE && -d $FP_ROOT_DIR){
#   print "!!WARN: NOT GENERATING NEW CACHE; RE-USING ALL OF PREVIOUS CACHE.
# This includes the following cache files from [$FP_ROOT_DIR]:
# --------------------------------------------------------------------
# $prev_cache
# --------------------------------------------------------------------
# If you want to ignore some of these cachefiles, delete them or move them out of the way.
# Hit [CTRL + C] to cancel or .. ";
#   if ($NOWAIT){
#     print " Actually... Not waiting.  You have 5 sec to cancel.\n";
#     sleep 5;
#   } else{ pause(); }
# 
#   # now have to populate the @cachefiles array from the existing cachefiles
#   my $nn = @cachefiles = split(/\n/,$prev_cache);
# } else {  # forking the fpart partitioner
  # make sure there's no other fpart's running.
  my $fparts_already_running = `ps aux | grep 'fpar[t]'`; chomp $fparts_already_running;
  if ($fparts_already_running ne ''){
    print "WARN: one or more 'fpart's are already running:
    ====
    [$fparts_already_running]
    ====
    Unless you know that these fparts are valid and not left over from previous 
    parsyncfp's, you should exit and kill them off before restarting this run.
    Continue? [Ny] ";
    my $ansr = <STDIN>;
    if ($ansr =~ /[yY]/) { print "\nOK, continuing\n"; }
    else {die "Fine - clear up the confusion and try again.\n"}
  }
  my $x = 0;
  my $cmd = "fpart -v -L -z -s $FPARTSIZE_N -o $FP_ROOT $fnd2r  2> $FPART_LOGFILE & echo \"\${!}\" > $FP_PIDFILE";
  # That captures the child PID!
  if ($DEBUG) {print "DEBUG: fpart fork cmd:\n[$cmd]\n";} sleep 5;
  if ($FPART_PID = fork) {
    if ($VERBOSE >= 2) { print "\nINFO: Forking fpart.  Check [$FPART_LOGFILE] for errors if it hangs.\n"; }
  } else {
  system "$cmd";
  $FPART_PID = `cat $FP_PIDFILE`; chomp $FPART_PID;
  exit(0); # it's forked, now exit this stanza
  }
  # fpart has been forked; wait for enough chunkfiles to be written to start the rsyncs
  while (! -e $FP_PIDFILE) { sleep 1;
    if ($VERBOSE >= 2) {print "INFO: Waiting for fpart to be forked..\n";}
  }
  $FPART_PID = `cat $FP_PIDFILE`; chomp $FPART_PID;
  my $ready2start = my $waitcnt = $NBR_FP_FLES = 0;
  my $fp0 = $FP_ROOT . ".0";
  my $fp1 = $FP_ROOT . ".1";
  my $done = 0;
  while ($ready2start == 0) {
    if (-e $fp0) {
      if ($VERBOSE >= 2) {print "INFO: [$fp0] visible.\n";}
      $NBR_FP_FLES++; $ready2start=1; 
    }
    $waitcnt++;
    if ($VERBOSE >= 2) {print "INFO: Waiting [$waitcnt]s for chunk files to be written\n";}
    sleep 1;
  }
#} # forking the fpart partitioner

# start up NP rsyncs 1st, then cycle every CHECKPERIOD, checking # of rsyncs still going and
# starting new ones as needed until the chunkfiles are exhausted.
my $STILL_FP_CHUNKS = my $KEEPGOING = 1;
my $FPCFS = "${FP_ROOT}."; # FP Chunk File Stem
my $NBR_FP_FLES = `\\ls -U1 ${FPCFS}* | wc -l`; chomp $NBR_FP_FLES;
$RSYNCS_GOING = $CUR_FPI = 0; # $CUR_FPI = current FP index

if ($VERBOSE >= 2) {print "\nINFO: Starting the 1st [$NP] rsyncs ..\n";}
my $sc = 0;
while ($RSYNCS_GOING < $NP && $KEEPGOING) { #
  $CUR_FP_FLE = $FP_ROOT . "." . $CUR_FPI ; # the current fp chunkfile
  if (-e $CUR_FP_FLE) { # if the current chunkfile exists
    fixfilenames($CUR_FP_FLE, $ROOTDIR);  # check & fix for spaces, bad chars.
    # entire rsync command and PID capture (used in total of 2 places)
    $logfile = $parsync_dir . '/' ."rsync-logfile-" . $DATE . "_" . $CUR_FPI;
    $RSYNC_CMD = "rsync  --bwlimit=$MAXBW  $RSYNCOPTS -as --log-file=$logfile --files-from=$CUR_FP_FLE  $ROOTDIR  $TARGET  & echo \"\${!}\" >> $PIDFILE";
    # there will be as many logfiles as fp chunkfiles.
    # ie LOTS. but they can be deleted after the run has been verified..
    # TODO don't know if we need this logfile.
    if ($DEBUG) {&debug(__LINE__, "Complete rsync cmd = [$RSYNC_CMD]");}
    system("$RSYNC_CMD"); # launch rsync and capture the bg job PID to PIDfile
    $CUR_FPI++;
    $RSYNCS_GOING++;
  } else { # there aren't any more fp chunk files waiting, so check to see if it's finished.
    $FPART_RUNNING = `ps aux | grep fpar[t] | grep $FPART_PID | wc -l`; chomp $FPART_RUNNING;
    print "IDEBUG: FPART_RUNNING = $FPART_RUNNING ('0' should end the loop)\n";
    if ($FPART_RUNNING eq '0') {
      # so if it's done, then we're done.  No more chunk files, so no more rsyncs to start.
      $KEEPGOING = 0; # signal the while loop to break.
    } else { # fpart is still going so wait for the next fpart chunkfile to be finished.
      if ($VERBOSE >= 2) {print "INFO: waiting [$sc]s for next chunkfile [$CUR_FP_FLE]\r";} sleep 2; $sc += 2;
    }
  }
}  #while ($RSYNCS_GOING < $NP && $KEEPGOING)

# so at this point either we've loaded all the rsyncs up to NP or we've completely finished.
# If the latter, say good bye.  If the former, then we have to keep launching
# rsyncs up to NP until we've used up all the fpart chunkfiles.

$sPIDs = ""; # running PIDs launched by parsync, suspended PIDs (strings)
$NBR_FP_FLES = `\\ls -U1 $FPCFS* | wc -l`; chomp $NBR_FP_FLES; # get current # of chunks
my @aprPIDs; # all recorded parsyncfp rsync PIDs ever started
my @crrPIDs; # currently RUNNING parsyncfp rsync PIDs.
my @csrPIDs; #currently SUSPENDED parsyncfp rsync PIDs.

### FOLLOWING IS THE MAIN PARSYNC-FPART LOOP
$FP_RUNNING = `ps aux | grep $FPART_PID | grep fpar[t] | wc -l`; chomp $FP_RUNNING;

$ cyclecnt = 0;
my $IFN = sprintf("%7s",$NETIF);
if ($VERBOSE == 1) {           printf "\n                    |   1m   |   MB/s    | Running || Susp'd  |      Chunks 
     Timestamp      |  Load  | [$IFN] |   PIDs  ||  PIDs   | [UpTo] of [ToDo]\n";}

while ($CUR_FPI < $NBR_FP_FLES || $FP_RUNNING || $STILLRSYNCS ) {
  $rPIDs = "";
  # print the header
  if ($hdr_cnt > $hdr_rpt) {
    my $glob = "${FP_ROOT}.*"; $hdr_cnt = 0;
    $nbr_cur_fpc_fles = `\\ls -U1 $glob | wc -l`; chomp $nbr_cur_fpc_fles;
    # if ($VERBOSE >= 1) {print "     Timestamp       | 1m Load | MB/s [$NETIF] | Running PIDs || Susp'd PIDs    Chunks      \n";}
     if ($VERBOSE > 1) {print "                   |   1m   |   MB/s    | Running || Susp'd  |      Chunks 
     Timestamp     |  Load  | [$IFN] |   PIDs  ||  PIDs   | [UpTo] of [ToDo]\n";}
  }
  ($rPIDs, $crr) = get_rPIDs($PIDFILE, $sPIDs);

  # now get load, bw, etc, and start rsyncs on new chunkfiles or suspend them to
  # load-balance

  $loadavg = `cat /proc/loadavg | tr -d '\n'`; # What's the system load?
  @SYSLOAD = split (/\s+/, $loadavg); # 1st 3 fields are 1, 5, 15m loads
  $LOAD1mratio = $SYSLOAD[0] / $NCPUs;

  # print out current data with the date
  $rPIDs =~ s/^\s+|\s+$//g ; $sPIDs =~ s/^\s+|\s+$//g ;  # trim leading & trailing whitespace
  my $NrPIDs = my @Lr = split(/\s+/, $rPIDs);
  my $NsPIDs = my @Ls = split(/\s+/, $sPIDs);
  my $glob = "${FP_ROOT}.*"; 
  $nbr_cur_fpc_fles = `\\ls -U1 $glob | wc -l`; chomp $nbr_cur_fpc_fles;

  # if fpart is done ($FPART_RUNNING = "")
  # $FPART_RUNNING = `ps aux | grep fpar[t] | grep $FPART_PID | wc -l`; chomp $FPART_RUNNING;
  #AND $CUR_FPI >= $nbr_cur_fpc_fles
  # AND there aren't any $rPIDs AND there aren't any $sPIDs
  # then I think we're done.
  # check fpart to see if it's still running..
  $FPART_RUNNING = `ps aux | grep fpar[t] | grep $FPART_PID | wc -l`; chomp $FPART_RUNNING;

  if ($rPIDs eq "" ){$rPIDs = "No running PIDs; will start more next cycle"}
  my $rDATE=`date +"%T_%F" | sed 's/:/./g' `; chomp $rDATE;
  
  # check cycles, print if exceed then reset counter.
  if ($cyclecnt++ > ($CHECKPERIOD - 4)) {

  my $avgsend;
  if ($Linux) {
    (my $avrecv, $avgsend) = getavgnetbw($NETIF); #,$CHECKPERIOD);
    chomp $avgsend; $avgsend = $avgsend / 1048576;
  } else {
    if ($DEBUG) {print "DEBUG: netstat lines next with myIP=[$myIP]\n";}
    my $o1_bytes = `netstat -bi | grep $myIP | awk '{print \$10}'`; sleep $CHECKPERIOD;
    my $o2_bytes = `netstat -bi | grep $myIP | awk '{print \$10}'`;
    $avgsend = ($o2_bytes - $o1_bytes) / $CHECKPERIOD / 1000000;
  }
  # this should switch from scrolling to overwrite when VERBOSE < 2
    if ($VERBOSE == 1) {
      printf "$rDATE  %5.2f  %9.2f       %2d    <>  %2d          [%d] of [%d]\r",
      $SYSLOAD[0],   $avgsend ,   $NrPIDs, $NsPIDs, $CUR_FPI, $nbr_cur_fpc_fles;
    }
   
    if ($VERBOSE >= 2) {printf "$rDATE  %5.2f  %9.2f       %2d    <>  %2d       [%4d] of [%4d]\n",
             $SYSLOAD[0],   $avgsend ,   $NrPIDs, $NsPIDs, $CUR_FPI, $nbr_cur_fpc_fles;}
  if ($DEBUG) {print "\nDEBUG: rPIDs = $rPIDs; sPIDs = $sPIDs\n";}
  $cyclecnt = 0; $hdr_cnt++;
  }
### SUSPEND OR CONTINUE RSYNCS for LOADBALANCING
  if ($SYSLOAD[0] > $MAXLOAD) {
    # suspend a PID; then loop as normal. If still high, will continue to
    # suspend PIDs until there's none left.
    if ($DEBUG) {print "\nDEBUG: System load [$SYSLOAD[0]] is > MAXLOAD [$MAXLOAD].  Will try to suspend a running rsync to shed load.\n";}
    # reassign a new list from ONLY RUNNING PIDs to $rPIDs (refresh $rPIDs)
    # this cmd picks up both suspended and running PIDs- have to remove the suspended ones.
    # in an efficient way.
    if ($rPIDs =~ /\d+/) {$rPIDs = `ps -p $rPIDs | grep -v PID| cut -c 1-5 | tr '\n' ' '`;}
    $rPIDs =~ s/^\s+|\s+$//g ; # trim leading and trailing
    # turn it into an array - (-> sub?)
    my $rn = my @ra = split(/\s+/, $rPIDs);
    my $sn = my @sa = split(/\s+/, $sPIDs);
    for (my $r=0; $r< $rn; $r++) {
      for (my $s=0; $s< $sn; $s++) {
      if ($ra[$r] eq $sa[$s]) {$rPIDs =~ s/$ra[$r]//g;} # delete it from $rPIDs
      }
    }
    # picks up both suspended and running PIDs
    # and the new result has to have something in it as well.
    if ($rPIDs =~ /\d+/){ # if any still left
      my $N = my @raPIDs = split(/\s+/, $rPIDs); my $e = 0; #@raPIDs = temp array to carry currently running PIDs
      while ($e <= $N && $raPIDs[$e] !~ /\d+/){$e++};
      if ($DEBUG) {print "\t\tDEBUG:got one: [$raPIDs[$e]]; will now suspend it\n";}
      kill 'STOP', $raPIDs[$e];
      if ($sPIDs !~ /$raPIDs[$e]/) { # If it's not there already
	$sPIDs = "$sPIDs" . ' ' . "$raPIDs[$e]"; # transfer rPID to sPID.
	$rPIDs =~ s/$raPIDs[$e]//g; # only then delete that PID fr the rPID string
      }
    } else { # there aren't any more PIDs left - all done or killed off.'
      if ($VERBOSE >= 2) {print "\tINFO: No more running rsync PIDs left [$rPIDs].  All rsyncs are suspended [$sPIDs].\n";}
    }
  } elsif ($sPIDs =~ /\d+/) { # if there are sPIDs, unsuspend them one by one
    # split em
    my $N = my @saPIDs = split(/\s+/, $sPIDs); my $e = 0;
    while ($e <= $N && $saPIDs[$e] !~ /\d+/){$e++};
    if ($DEBUG) { print "\t\tDEBUG:got one: [$saPIDs[$e]]; will now UNsuspend it\n";}
    kill 'CONT', $saPIDs[$e];
    $rPIDs = "$rPIDs" . ' ' . "$saPIDs[$e]"; # transfer sPID to rPID.
    $sPIDs =~ s/$saPIDs[$e]//g; # delete that PID fr the sPID string
  } # end of 'SUSPEND OR CONTINUE to LOADBALANCE.' test loop
  # and if neither of those conditions are met, then we can launch another rsync.
  elsif  ($crr < $NP) { # then launch another rsync with the next fpart chunkfile
#    $CUR_FP_FLE = $FP_ROOT . "." . $CUR_FPI ; # generate the next fpart chunk file with $CUR_FPI
    $CUR_FP_FLE = "${FP_ROOT}.${CUR_FPI}" ; # generate the next fpart chunk file with $CUR_FPI
      # if fpart is still going, wait for the next chunkfile to show up
    my $cfw = 0;
    if ($REUSECACHE) {$FPART_RUNNING = 0;}
    else { $FPART_RUNNING = `ps aux | grep fpar[t] | grep $FPART_PID | wc -l`; chomp $FPART_RUNNING;}
    while (! -e $CUR_FP_FLE && $FPART_RUNNING eq '1'){
      if ($VERBOSE >= 2) {print "INFO: Waiting [$cfw] s for next chunkfile..\r"; sleep 2; $cfw += 2;}
    }
    ($rPIDs, $crr) = get_rPIDs($PIDFILE, $sPIDs);
    my $n = my @a = split(/\s+/, $rPIDs);
    my $R2SU = $NP - $n; # this is the number of rsyncs to start up
    $glob = "${FP_ROOT}.*";
    my $nbr_cur_fpc_fles = `\\ls -U1 $glob | wc -l`; chomp $nbr_cur_fpc_fles;
    # $fparts_already_running will be '' if it's finished running.
    my $fparts_already_running = `ps aux | grep 'fpar[t]'`; chomp $fparts_already_running;
    # Check this more carefully for exceptions - this is the drop-dead error point
    # in some situations
    for ($n=0; $n<$R2SU; $n++) {
      # make sure we haven't finished
      $FPART_RUNNING = `ps aux | grep fpar[t] | grep $FPART_PID | wc -l`; chomp $FPART_RUNNING;

        if ($rPIDs eq "" && $sPIDs eq "" && $CUR_FPI >= $nbr_cur_fpc_fles && $FPART_RUNNING == 0){
            # then we're done - exit.
            if ($VERBOSE >= 2) {print "\nINFO: Done.  Please check the target to make sure 
  expected files are where they're supposed to be. \n";}
            
            # remind user how much storage the cache takes and to clear the cache files 
            my $du_cache = `du -sh $parsync_dir`; chomp $du_cache;
            if ($VERBOSE >= 2) {print "
INFO: The parsyncfp cache dir takes up [$du_cache]
    Don't forget to delete it, but wait until you are sure that your job
    completed correctly, so you don't need the log files anymore.\n";}
            exit;
        }
        while  (($CUR_FPI >= $nbr_cur_fpc_fles) && $fparts_already_running ne '') {
            if ($DEBUG) {print "DEBUG: CUR_FPI=$CUR_FPI >= nbr_cur_fpc_fles=$nbr_cur_fpc_fles?\n";}
            if ($VERBOSE >= 2) {print "INFO: Waiting for fpart to get ahead of the transfer..\r"; }
            $nbr_cur_fpc_fles = `\\ls -U1 $glob | wc -l`; chomp $nbr_cur_fpc_fles;
            $fparts_already_running = `ps aux | grep 'fpar[t]'`; chomp $fparts_already_running;
            sleep 2;
        }
        $logfile = $parsync_dir . '/' ."rsync-logfile-" . $DATE . "_" . $CUR_FPI;
        $CUR_FP_FLE = "${FP_ROOT}.${CUR_FPI}" ; # generate the next fpart chunk file with $CUR_FPI
        $nbr_cur_fpc_fles = `\\ls -U1 $glob | wc -l`; chomp $nbr_cur_fpc_fles;
        $RSYNC_CMD = "rsync  --bwlimit=$MAXBW -a --log-file=$logfile $RSYNCOPTS  --files-from=$CUR_FP_FLE  $ROOTDIR  $TARGET & echo \"\${!}\" >> $PIDFILE";
        if ($DEBUG) {print "\nDEBUG: Starting [$RSYNC_CMD]\n"; }

        # check status in a 1s loop checking to start extra rsyncs do we don't wait any more than 1s
        # OR keep cycling continuously on a 1s loop and ONLY print out info every X cycles.  This is the easiest way. 
        if (-e $CUR_FP_FLE) {
            fixfilenames($CUR_FP_FLE, $ROOTDIR);  # check & fix for spaces, bad chars.
            if ($VERBOSE >= 2) {"\tINFO: next chunk [", ($CUR_FPI+1), "] of [$nbr_cur_fpc_fles]\n";}
            system("$RSYNC_CMD"); # capture the bg job PID to PIDfile
            $CUR_FPI++;
        }
    }
    ($rPIDs, $crr) = get_rPIDs($PIDFILE, $sPIDs);
  }
  # sleep 1;
  $NBR_FP_FLES = `\\ls -U1 ${FPCFS}* | wc -l`; chomp $NBR_FP_FLES; # get current # of chunks
  if ($rPIDs =~ /\d+/) {
    $STILLRSYNCS = 1;
    
  }
  else {$STILLRSYNCS = 0;}
}  # while ($CUR_FPI < $NBR_FP_FLES )

my $host = `hostname`;
if (defined $EMAIL){system("echo 'all rsyncs done' | mail -s 'parsyncfp on host [$host] completed' $EMAIL");}


# and based on --disposal, (=c(ompress), =d(elete) =l(eave untouched)  all the chunk files.
if ($DISPOSE =~ /d/) {
  if ($VERBOSE >= 2) {print ".. and finally disposing of the cache...";}
  system("\\rm -rf ${FP_ROOT_DIR}/f*"); 
}
elsif ($DISPOSE =~ /c/ ) { # can it just be put into background?
  if ($VERBOSE >= 2) {print ".. tarring up your cachefiles...";}
  $cmd="tar --remove-files -czf ${parsync_dir}/fpcache_${DATE}.tar.gz ${FP_ROOT_DIR} &";
  #print "final tar cmd: [$cmd] \n";
  system ("$cmd");
} elsif ($VERBOSE >=2 ) {
  print "\n\nINFO: Your cache files have been left intact in [${FP_ROOT_DIR}]. 
  Please dispose of them as you see fit.";
}

if ($VERBOSE >=1) {
  print "\n\nThanks for using parsyncfp. Tell me how to make it better
  <hjmangalam\@gmail.com>\n";}
exit;


# ================= subroutines =================


# Define utilities required to run this version of parsync
sub check_utils {
  my %UTILS = (  # required utils to help this run correctly
    "ethtool"   => "",
    "iwconfig"  => "",
    "fpart"     => "",
  );
  # and check that they can be found..
  my $utilsz = keys %UTILS;
  foreach my $util (keys %UTILS){
    my $utilpath = `which $util | tr -d '\n'`;
    if ($utilpath !~ /$util/){
      print "!!WARN: [$util] not found.  you can 'fpart' here:
	<http://moo.nac.uci.edu/~hjm/parsync/utils>
      and the rest via yum, apt-get, or google.\n";
      die "\n\nFATAL: [$util] isn't on your PATH [$PATH]; Please install it or correct your PATH variable to include it.\nTry ''module load perl'' or use cpan to install it.\n\n"
    } else {$UTILS{$util} = $utilpath;
      if ($DEBUG){print "\tEVAL: Found [$util] at [$utilpath].\n"}
    }
  }
}


# usage:  ($rPIDs, $crr) = get_rPIDs($PIDFILE, $sPIDs);
sub get_rPIDs($$) {
# Inputs
  my $pidfile = shift; # string name of PIDFILE
  my $spids = shift;   # suspended PIDs in a string.
 
  my @aprPIDs = ();
  my $NSusPIDs = 0; 
  my @SusPIDs;
  my $rpids = ""; # to be generated and returned as a string
  my @crrPIDs = (); # array that holds the currently running rsync PIDs
  my @ASRP;  # All System Rsync PIDs
  my $NASRP;
  my $crr = 0;# currently running rsyncs counter
  my @crrPIDs = ();
  my $apr = 0;  # all parsyncfp rsync PIDs
  # how many rsyncs are running?  Check the PIDFILE against the rsync PIDs that are running
  # if there are other rsyncs running, their PIDs won't be in the PIDFILE.
  # so have to do a diff of the PIDFILE vs all PIDs of rsyncs running.
  my $ALL_SYS_RSYNC_PIDS = `ps aux | grep rsyn[c] |  awk '{print $2}' | sort -g | tr '\n' ' '`;  chop $ALL_SYS_RSYNC_PIDS;
  $NASRP = @ASRP = split(/\s+/, $ALL_SYS_RSYNC_PIDS);
  open (PIDFILE, "<$pidfile") or die "\nFATAL: Can't open PIDFILE [$pidfile]'.\n";
  # PIDs from the PIDFILE to compare system rsyncs (could be multiple going)
  # with parsync-launched rsyncs
  while (<PIDFILE>) {chomp;  $aprPIDs[$apr++] = $_; } # all parsyncfp rsync PIDs
  close PIDFILE;
  # if there are any PIDs in the $spids string, split into an array
  if ($spids =~ /\d+/) { $NSusPIDs = @SusPIDs = split(/\s+/, $spids); }
  $rpids =~ s/^\s+|\s+$//g ; $spids =~ s/^\s+|\s+$//g ; # strip leading/trailing spaces
  # suboptimal I know, but the arrays are so small it doesn't matter.
  for (my $a=0; $a<$NASRP; $a++) {
    for (my $b=0; $b<$apr; $b++) {
      # if they match, they're MY rsyncs AND they're running
      if ($ASRP[$a] eq $aprPIDs[$b]) {
	$crrPIDs[$crr++] = $aprPIDs[$b];
      }
    }
  }
  # dump @crrPIDs into $rpids
  $rpids = join(" ", @crrPIDs);
  $crr--; # trim off the extra incr
  
  # now mask out the sPIDs from the rPIDs list; works but ugly!
  $spids =~ s/^\s+|\s+$//g ;
  if ($spids =~ /\d+/) { # if there are any spids
    $NSusPIDs = @SusPIDs = split(/\s+/, $spids);
    for (my $r=0; $r<$NSusPIDs; $r++) {
      for (my $b=0; $b<$apr; $b++) {
	# if a sPID == rPID, delete the PID from the $rPIDs string
	if ( $SusPIDs[$r] eq $aprPIDs[$b]) { $rpids =~ s/$aprPIDs[$b]//g;}
      }
    }
  }
  return ($rpids, $crr);
}

sub getavgnetbw ($$) { # call as ($avrecv, $avgsend) = getavgnetbw($NETIF)
    my ($avgrec,$avgtrans,$R1,$T1,$R2,$T2);
    my $NETIF = shift; #my $CHECKPERIOD = shift;
    my $file = shift;   #, my $reps = shift;
    $R1=`cat /sys/class/net/${NETIF}/statistics/rx_bytes`; 
    $T1=`cat /sys/class/net/${NETIF}/statistics/tx_bytes`;
    sleep 1; #$CHECKPERIOD;
    $R2=`cat /sys/class/net/${NETIF}/statistics/rx_bytes`; 
    $T2=`cat /sys/class/net/${NETIF}/statistics/tx_bytes`;
    $avgrec = ($R2 - $R1);# / $CHECKPERIOD;
    $avgtrans = ($T2 - $T1); # / $CHECKPERIOD;
    return ($avgrec, $avgtrans);
}

# below is the variant that uses a time period to check over that time.
# sub getavgnetbw ($$) { # call as ($avrecv, $avgsend) = getavgnetbw($NETIF,$CHECKPERIOD)
#     my ($avgrec,$avgtrans,$R1,$T1,$R2,$T2);
#     my $NETIF = shift; my $CHECKPERIOD = shift;
#     my $file = shift;   #, my $reps = shift;
#     $R1=`cat /sys/class/net/$NETIF/statistics/rx_bytes`; 
#     $T1=`cat /sys/class/net/$NETIF/statistics/tx_bytes`;
#     sleep $CHECKPERIOD;
#     $R2=`cat /sys/class/net/$NETIF/statistics/rx_bytes`; 
#     $T2=`cat /sys/class/net/$NETIF/statistics/tx_bytes`;
#     $avgrec = ($R2 - $R1) / $CHECKPERIOD;
#     $avgtrans = ($T2 - $T1) / $CHECKPERIOD;
#     return ($avgrec, $avgtrans);
# }


sub pause {
    print "Press [ENTER] to continue.\n";
    my $tmp = <STDIN>;
}

# call as [debug(__LINE__, "string")] to print line # and debug string
sub debug($$) {
	my $line = shift;
	my $msg = shift;
	print STDERR "DEBUG[$line]: $msg\n";
	pause;
}

# fixfilenames reads in a file of filenames and iterates over them, fixing their
# names and emitting useful warning if something goes odd.
sub fixfilenames {
  my $FN = shift;
  my $startdir = shift; $startdir .= '/';
  my $fpnew =  $FN . ".new";
  open (FP, "< $FN") or die "ERROR: Can't open fp file [$FN]\n.";
  open (FPN, "> $fpnew") or die "ERROR: Can't open replacement file [$fpnew]\n.";
  my $lc = my $fws = my $verified = my $failed = 0;
  while (<FP>) {
    chomp;
      if ($_ =~ / /) {  # subst all spaces with '\ '
	$fws++;  s/ /\ /g;
      }
      # and also delete off the startdir
      s/$startdir//g;
      print FPN "$_\n";
  }
  close FP;  close FPN;
rename $fpnew, $FN; # and then rename the new one to the original
}


# ptgmk converts values suffixed with [PpTtGgMmKk] to bytes correctly
# uses the 1024 bytes/kb as oppo to 1000
sub ptgmk {
  my $instr = shift;
  # trim spaces from back and front
  $instr =~ s/^\s+|\s+$//g;
  my $abbr = chop $instr;
  my $nbr = $instr;
  if ($abbr !~ /[PpTtGgMmKk]/) {die "\n\nFATAL: tgmk() input doesn't contain [TtGgMmKk], so nothing to convert.\n\n"; }
  if ($abbr =~ /[Kk]/) {$nbr *= 1024; return $nbr;}
  if ($abbr =~ /[Mm]/) {$nbr *= 1048576; return $nbr;}
  if ($abbr =~ /[Gg]/) {$nbr *= 1073741824; return $nbr;}
  if ($abbr =~ /[Tt]/) {$nbr *= 1.09951162778e+12; return $nbr;}
  if ($abbr =~ /[Pp]/) {$nbr *= 1.12589990684e+15; return $nbr;}
}

sub usage {
  #my $parsync_dir = shift;
  my $helpfile = "$HOME/.parsyncfp/parsyncfp-help.tmp";
  if (! -d "$HOME/.parsyncfp") {mkdir "$HOME/.parsyncfp";}
  open HLP, ">$helpfile" or die "Can't open the temp help file [$helpfile]\n";
  my $helptxt = <<HELP;

$PARSYNCVER
The only native rsync option that parsyncfp uses is '-a (archive).  If you
need more, then it's up to you to provide them ALL via '--rsyncopts'.
parsyncfp checks to see if the current system load is too heavy and tries
to throttle the rsyncs during the run by monitoring and suspending
/ continuing them as needed.

parsyncfp uses fpart <http://goo.gl/K1WwtD> to create chunkfiles for rsync
to read, bypassing the need to wait for a complete recursive scan. ie, it 
starts the transfer immediately. For large deep trees, this can be useful.

It appropriates rsync's bandwidth throttle mechanism, using '--maxbw'
as a passthru to rsync's 'bwlimit' option, but divides it by NP so
as to keep the total bw the same as the stated limit.  It monitors and
shows network bandwidth, but can't change the bw allocation mid-job.
It can only suspend rsyncs until the load decreases below the cutoff.
If you suspend parsyncfp (^Z), all rsync children will suspend as well,
regardless of current state.

Unless changed by '--interface', it assumes and monitors the routable interface.  
The transfer will use whatever interface normal routing provides, normally
set by the name of the target.  It can also be used for non-host-based
transfers (between mounted filesystems) but the network bandwidth continues
to be (pointlessly) shown.

[[NB: Between mounted filesystems, parsyncfp sometimes works very poorly for
reasons still mysterious.  In such cases (monitor with 'ifstat'), use 'cp'
for the initial data movement and a single rsync to finalize.  I believe
the multiple rsync chatter is interfering with the transfer.]]

It only works on dirs and files that originate from the current dir (or
specified via "--startdir").  You cannot include dirs and files from
discontinuous or higher-level dirs.  parsyncfp also does not use rsync's 
sophisticated/idiosyncratic treatment of trailing '/'s to direct where 
files vs dirs are sent; dirs are treated as dirs regardless of the 
trailing '/'.

** the [.parsyncfp] files **
The [.parsyncfp] dir contains the cache dir (fpcache), and the time-
stamped log files, which are not NOT overwritten.

** Odd characters in names **
parsyncfp will refuse to transfer some oddly named files (tho it should copy
filenames with spaces fine.  Filenames with embedded newlines, DOS EOLs,
and some other odd chars will be recorded in the log files in the 
[.parsyncfp] dir.

OPTIONS
=======
[i] = integer number
[f] = floating point number
[s] = "quoted string"
( ) = the default if any

--NP|np [i] (sqrt(#CPUs)) ..............  number of rsync processes to start
       optimal NP depends on many vars.   Try the default and incr as needed
--altcache|ac (~/.parsyncfp) ..... alternative cache dir for placing it on a
                                          another FS or for running multiple 
                                                   parsyncfps simultaneously
--startdir|sd [s] (`pwd`)  ..................  the directory it starts at(*)
--maxbw [i] (unlimited) ...........  in KB/s max bandwidth to use (--bwlimit
       passthru to rsync).  maxbw is the total BW to be used, NOT per rsync.
--maxload|ml [f] (NP+2)  ..........  max system load - if sysload > maxload,
                                            an rsync proc will sleep for 10s
--chunksize|cs [s] (10G) .... aggregate size of files allocated to one rsync
                      process.  Can specify in 'human' terms [100M, 50K, 1T]
                                                   as well as integer bytes.
--rsyncopts|ro [s]  ...  options passed to rsync as quoted string (CAREFUL!)
         this opt triggers a pause before executing to verify the command(+)
--interface|i [s]  ......  network interface to monitor (not use; see above)
--checkperiod|cp [i] (5) ........ sets the period in seconds between updates
--verbose|v [0-3] (2) ...sets chattiness. 3=debug; 2=normal; 1=less; 0=none
                    This only affects verbosity post-start; warning & error
                    messages will still be printed.
--dispose|d [s] (l) .... what to do with the cache files. (l)eave untouched,
                                          (c)ompress to a tarball, (d)elete.
--email [s]  .....................  email address to send completion message
--nowait  .............  for scripting, sleep for a few s instead of pausing
--version  .................................  dumps version string and exits
--help  .........................................................  this help

(*) you can use globs/regexes with --startdir, but only if you're at that
point in the dir tree. ie: if you're not in the dir where the globs can be
expanded, then the glob will fail.  However, explicit dirs can be set from
anywhere if given an existing startdir.

(+) the '--rsyncopts' string can pass any rsync option to all the rsyncs that
will be started.  This allows options like '-z' (compression) or '--exclude-from' 
to filter out unwanted files. Use any 'delete' options carefully tho.

Examples
========
(Good example)
% parsyncfp  --maxload=5.5 --NP=4 --startdir='/home/hjm' dir[123]  \
hjm\@remotehost:~/backups

where
  = "--startdir='/home/hjm'" sets the working dir of this operation to
      '/home/hjm' and dir1 dir2 dir3 are subdirs from '/home/hjm'
  = the target "hjm\@remotehost:~/backups" is the same target rsync would use
  = "--NP=4" forks 4 instances of rsync
  = -"-maxload=5.5" will start suspending rsync instances when the 1m system
      load gets to 5.5 and then unsuspending them when it goes below it.

  It uses 4 instances to rsync dir1 dir2 dir3 to hjm\@remotehost:~/backups


(Good example)
% parsyncfp --reusecache  --NP=3 --barefiles  *.txt   /mount/backups/txt

where
  = "--reusecache" indicates that the filecache shouldn't be re-generated,
    uses the previous filecache in ~/.parsync
  = "--NP=3" for 3 copies of rsync (with no "--maxload", the default is 4)
  = "--barefiles" indicates that it's OK to transfer barefiles instead of
    recursing thru dirs.
  = "/mount/backups/txt" is the target - a local disk mount instead of a network host.

  It uses 3 instances to rsync *.txt from the current dir to "/mount/backups/txt".


(Good example 1)
parsyncfp   --checkperiod 6  --NP 3 --interface eth0  --chunksize=87682352 \
   --rsyncopts="--exclude='[abc]*'"  nacs/fabio   hjm\@moo:~/backups

The above command shows several options used correctly:

--chunksize=87682352 - shows that the chunksize option can be used with explicit
integers as well as the human specifiers (TGMK).

--rsyncopts="--exclude='[abc]*'" - shows the correct form for excluding files
based on regexes (note the quoting)

nacs/fabio - shows that you can specify subdirs as well as top-level dirs (as
long as the shell is positioned in the dir above, or has been specified via
'--startdir'

(Good example 2)
parsyncfp -v 1 --nowait --ac pfpcache1 --NP 4 --cp=5 --cs=50M --ro '-az'  \
linux-4.8.4 moo:~/test

The above command shows:
- short version of several options (-v for --verbose, --cp for checkperiod, etc)
- shows use of --altcache (--ac pfpcache1), writing to relative dir pfpcache1
- again shows use of --rsyncopts (--ro '-az') indicating 'archive' & compression'.
- includes '--nowait' to allow unattended scripting of parsyncfp


(Error Example)
% pwd
/home/hjm  # executing parsyncfp from here

% parsyncfp --NP4  /usr/local  /media/backupdisk

why this is an error:
  = '--NP4' is not an option (parsyncfp will say "Unknown option: np4"
    It should be '--NP=4' or '--NP 4'
  = if you were trying to rsync '/usr/local' to '/media/backupdisk', it will
    fail since there is no /home/hjm/usr/local dir to use as a source.
    This will be shown in the log files in ~/.parsync/rsync-logfile-<datestamp>_#
    as a spew of "No such file or directory (2)" errors

The correct version of the above command is:

% parsyncfp --NP=4  --startdir=/usr  local  /media/backupdisk

HELP

#--reusecache  ..........  don't re-read the dirs; re-use the existing caches


  print HLP $helptxt;
  close HLP;
  system("less -S $helpfile");
  unlink $helpfile;
  die "Did that help?.\n";
}
